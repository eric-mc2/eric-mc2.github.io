<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Eric Chandler | Chicago Transit Ridership Panel</title>
  <meta name="description" content="Collecting a unified time series econometric dataset.">

  
  
    <meta property="og:image" content="https://eric-mc2.github.io/img/headshot.png" />
    <meta property="og:title" content="Eric Chandler | Chicago Transit Ridership Panel" />   
  
  <meta property="og:description" content="Collecting a unified time series econometric dataset." />
  <meta name="author" content="Eric Chandler">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
  
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&family=Saira+Extra+Condensed:wght@100;200;300;400;500;600;700;800;900&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&family=Saira+Extra+Condensed:wght@100;200;300;400;500;600;700;800;900&display=swap"></noscript>
  <link rel="preload" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css"></noscript>
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/devicons/1.8.0/css/devicons.min.css" integrity="sha512-JW3fT0YTK7pT7w437SoX6GcW76jOZ6E0jGmrqBAcloC4GKT+njHOY4fX5KxJ9WfIXTkNrAF994525fAHp+KCxg==" crossorigin="anonymous" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/devicons/1.8.0/css/devicons.min.css" integrity="sha512-JW3fT0YTK7pT7w437SoX6GcW76jOZ6E0jGmrqBAcloC4GKT+njHOY4fX5KxJ9WfIXTkNrAF994525fAHp+KCxg==" crossorigin="anonymous"></noscript>
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css" integrity="sha512-QKC1UZ/ZHNgFzVKSAhV5v5j73eeL9EEN289eKAEFaAjgAiobVAnVv/AGuPbXsKl1dNoel3kNr6PYnSiTzVVBCw==" crossorigin="anonymous" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css" integrity="sha512-QKC1UZ/ZHNgFzVKSAhV5v5j73eeL9EEN289eKAEFaAjgAiobVAnVv/AGuPbXsKl1dNoel3kNr6PYnSiTzVVBCw==" crossorigin="anonymous"></noscript>
  
  <link rel="preload" href="https://eric-mc2.github.io/css/base.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://eric-mc2.github.io/css/base.css"></noscript>
  <link rel="preload" href="https://eric-mc2.github.io/css/nav.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://eric-mc2.github.io/css/nav.css"></noscript> 
  <link rel="preload" href="https://eric-mc2.github.io/css/content.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://eric-mc2.github.io/css/content.css"></noscript>
  <link rel="preload" href="https://eric-mc2.github.io/css/tweaks.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://eric-mc2.github.io/css/tweaks.css"></noscript>
  <meta name="generator" content="Hugo 0.123.8">
  
    
    
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>
    
  
</head>
<body id="page-top">
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
  <a class="navbar-brand js-scroll-trigger" href="#page-top">
    <span class="d-block d-lg-none">Eric Chandler</span>
    <span class="d-none d-lg-block">
      <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="/img/headshot.png" alt="">
    </span>
  </a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link js-scroll-trigger" href="/#about">About</a>
      </li>
      
      <li class="nav-item">
        <a class="nav-link js-scroll-trigger" href="/#education">Education</a>
      </li>
      
      <li class="nav-item">
        <a class="nav-link js-scroll-trigger" href="/#experience">Experience</a>
      </li>
      
      <li class="nav-item">
        <a class="nav-link js-scroll-trigger" href="/#projects">Projects</a>
      </li>
      
      <li class="nav-item">
        <a class="nav-link js-scroll-trigger" href="/#publications">Publications</a>
      </li>
      
      
    </ul>
  </div>
</nav>
  <div class="container-fluid p-0">
    
<nav aria-label="breadcrumb">
  <ol  class="breadcrumb">
    





<li class="breadcrumb-item">
  <a href="https://eric-mc2.github.io/">Eric Chandler</a>
</li>


<li class="breadcrumb-item">
  <a href="https://eric-mc2.github.io/projects/">Projects</a>
</li>


<li class="breadcrumb-item active">
  <a href="https://eric-mc2.github.io/projects/dnc-transit/">Chicago Transit Ridership Panel</a>
</li>

  </ol>
</nav>




<section class="project-section p-3 p-lg-5 d-flex d-column">
  <div class="my-auto">
    <h2 class="mb-0"><span class="text-primary">Chicago Transit Ridership Panel</span></h2>
    <p>Project link: <a href="https://github.com/eric-mc2/DNCTransit">https://github.com/eric-mc2/DNCTransit</a></p>
    <p>This page describes the steps I took to create a panel dataset of ridership
across different Chicago transit systems. I did this to practice econometric modeling.</p>
<h1 id="transit-modes-and-data-sources">Transit modes and data sources</h1>
<p><strong>Included modes</strong></p>
<ul>
<li>Train, Bus, Rideshares - from the City of Chicago (used Socrata API and sodapy python package)</li>
<li>Bikeshares aka Divvy Bikes - from Lyft (used s3fs python package to access public Amazon S3 bucket)</li>
</ul>
<p><strong>Excluded modes</strong></p>
<ul>
<li>Metra commuter rail (public data is available but too coarsely aggregated)</li>
<li>Pace city-suburb bus link (have not checked availability)</li>
<li>Walking / Biking (vendored data is available &ndash; ie cell phone location data &ndash;
but would be hard to isolate from other transit modalities)</li>
<li>Driving (public data is available &ndash; ie road segment usage &ndash; but haven&rsquo;t seriously looked yet)</li>
</ul>
<p><strong>Extra data</strong></p>
<ul>
<li>Geographic boundaries - from US Census Bureau (used pygris python package)</li>
<li>Landmark boundaries - also from City of Chicago</li>
</ul>
<h1 id="etl-pipeline">ETL Pipeline</h1>
<p>Major steps in processing this data:</p>
<ol>
<li>Extract
<ol>
<li>Get raw unit-level data (i.e. train stations, bus lines)</li>
<li>Get raw ridership time series data</li>
</ol>
</li>
<li>Transform
<ol>
<li>Account for schema drift in each data source</li>
<li>Merge unit info and time series data</li>
<li>Compute and add covariates for regression</li>
</ol>
</li>
<li>Merge
<ol>
<li>Merge transit modalities at different spatial and time aggregations</li>
</ol>
</li>
<li>Choose
<ol>
<li>Choose best aggregation for regression modeling</li>
</ol>
</li>
</ol>
<h2 id="etl-illustration">ETL Illustration</h2>
<p>Some datasets were better organized than others. The easier ones only required:</p>
<ul>
<li>selecting spatial and time range to query</li>
<li>reading data documentation</li>
<li>figuring out which are the table primary and foreign keys</li>
<li>light conversion of data and object types</li>
</ul>
<p>In the simplest of cases, here&rsquo;s all the code we need to query and arrange a panel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> src.data.cta <span style="color:#f92672">import</span> (ChiClient, 
</span></span><span style="display:flex;"><span>                          BUS_ROUTES_TABLE, 
</span></span><span style="display:flex;"><span>                          BUS_RIDERSHIP_TABLE)
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> src.data.gis <span style="color:#f92672">import</span> WORLD_CRS
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> shapely.geometry <span style="color:#f92672">import</span> shape
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Query static info about bus routes</span>
</span></span><span style="display:flex;"><span>client <span style="color:#f92672">=</span> ChiClient(<span style="color:#ae81ff">60</span>)
</span></span><span style="display:flex;"><span>bus_routes <span style="color:#f92672">=</span>  client<span style="color:#f92672">.</span>get_all(BUS_ROUTES_TABLE, select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;the_geom, route, name&#34;</span>)
</span></span><span style="display:flex;"><span>bus_routes <span style="color:#f92672">=</span> (bus_routes
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>assign(geometry <span style="color:#f92672">=</span> bus_routes[<span style="color:#e6db74">&#39;the_geom&#39;</span>]<span style="color:#f92672">.</span>apply(shape))
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>drop(columns<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;the_geom&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>pipe(gpd<span style="color:#f92672">.</span>GeoDataFrame, crs<span style="color:#f92672">=</span>WORLD_CRS))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Query daily rides per route</span>
</span></span><span style="display:flex;"><span>data_start <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;2024-01-01T00:00:00&#34;</span>
</span></span><span style="display:flex;"><span>data_end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;2024-08-31T23:59:59&#34;</span>
</span></span><span style="display:flex;"><span>bus_rides <span style="color:#f92672">=</span> client<span style="color:#f92672">.</span>get_all(BUS_RIDERSHIP_TABLE, 
</span></span><span style="display:flex;"><span>                            select<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;route,date,daytype,rides&#34;</span>,
</span></span><span style="display:flex;"><span>                            where<span style="color:#f92672">=</span><span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;date between &#39;</span><span style="color:#e6db74">{</span>data_start<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39; and &#39;</span><span style="color:#e6db74">{</span>data_end<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bus_panel <span style="color:#f92672">=</span> bus_rides<span style="color:#f92672">.</span>merge(bus_routes, how<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;left&#39;</span>, on<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;route&#39;</span>)
</span></span></code></pre></div><p>Let&rsquo;s plot these routes, colored by ridership:</p>


<div id="/json/bus-route-rides.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/bus-route-rides.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/bus-route-rides.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<p>After getting the direct transit data, I coded a few extra features such as
census tract and population, which could serve as useful regression controls later on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> pygris
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># CTA routes extend outside chicago into cook cty.</span>
</span></span><span style="display:flex;"><span>tracts <span style="color:#f92672">=</span> pygris<span style="color:#f92672">.</span>tracts(state<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;IL&#39;</span>, county<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cook&#39;</span>, cb<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, year<span style="color:#f92672">=</span><span style="color:#ae81ff">2020</span>, cache<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>tracts <span style="color:#f92672">=</span> tracts[[<span style="color:#e6db74">&#39;GEOID&#39;</span>,<span style="color:#e6db74">&#39;geometry&#39;</span>]]
</span></span><span style="display:flex;"><span>tracts[<span style="color:#e6db74">&#39;GEOID&#39;</span>] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>to_numeric(tracts[<span style="color:#e6db74">&#39;GEOID&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">code_tract</span>(gdf, tracts_gdf) <span style="color:#f92672">-&gt;</span> pd<span style="color:#f92672">.</span>Series:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;Spatial join points to census tract&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    codes <span style="color:#f92672">=</span> (gdf
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>filter([<span style="color:#e6db74">&#39;geometry&#39;</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>to_crs(tracts_gdf<span style="color:#f92672">.</span>crs)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>sjoin(tracts_gdf, how<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;left&#39;</span>, predicate<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;within&#39;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pd<span style="color:#f92672">.</span>concat([gdf, codes[<span style="color:#e6db74">&#39;GEOID&#39;</span>]<span style="color:#f92672">.</span>rename(<span style="color:#e6db74">&#39;tract&#39;</span>), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bus_stops <span style="color:#f92672">=</span> bus_stops<span style="color:#f92672">.</span>pipe(code_tract)
</span></span></code></pre></div><p>Now we know the immediate population served by each bus line.</p>


<div id="/json/bus-route-pop.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/bus-route-pop.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/bus-route-pop.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<p>Since ridership is reported at different levels of granularity for each transit modality, I had to be careful how to spatially aggregate the data. My goal is to test whether local events, such as football games, have a measurable effect on transit. Associating transit stations to points of interest is straightforward &ndash; each point is an unambiguous distance away. Associating shapes such as bus routes or census tracts is more ambiguous &ndash; do we measure the distance to the closest bus stop or the furthest? The data doesn&rsquo;t tell us whether riders travel short or far distances along these routes. This ambiguity can create inaccurate regression estimates.</p>
<p><img src="/img/point-line-dist.jpeg" alt="Distance to point-of-interest"></p>
<ul>
<li>Train: provides daily boarding counts per station. we do not know where each passenger exited, nor which direction or train route they took.</li>
<li>Bus: provides daily boardings counts per route. we do not know how this breaks down per bus stop, nor the direction or stop passengers exited at.</li>
<li>Bike: provides trip-level data: timestamped station pickups and dropoffs per ride.</li>
<li>Bike: provides trip-level data: timestamped pickup and dropoffs per ride. pickup and dropoff points are anonymized to their containing census tract.</li>
</ul>
<table>
<thead>
<tr>
<th>Modality</th>
<th>Train</th>
<th>Bus</th>
<th>Bike</th>
<th>Uber</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Time granularity</strong></td>
<td>Daily</td>
<td>Daily</td>
<td>Minute</td>
<td>Minute</td>
</tr>
<tr>
<td><strong>Direction of travel</strong></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Point of departure</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Line of departure</strong></td>
<td>Inferred</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Area of departure</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Point of arrival</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Line of arrival</strong></td>
<td>Inferred</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Area of arrival</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p>I aggregated three comparable panels:</p>
<ul>
<li>Point: train, bike</li>
<li>Line: train, bus</li>
<li>Area: train, bike, uber</li>
</ul>


<div id="/json/tracts-viz.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/tracts-viz.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/tracts-viz.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<h2 id="special-challenges">Special Challenges</h2>
<h3 id="divvy-locations">Divvy Locations</h3>
<p>The divvy historical data spans from 2013 to 2024. Over these years, the published
schema has changed several times. This led to annoying, but forgiveable issues
to work around:</p>
<p><em>Batch Size:</em> Some years are published in monthly batches, others quarterly.
This isn&rsquo;t an issue for data modeling, since we just concatenate, but it requires
extra logic for properly discovering and enumerating the available data.</p>
<p><em>Inconsistent column names:</em> Also not an issue for modeling, since I just rename them,
but requires manually curating a mapping of {old name -&gt; new name} .</p>
<p><em>Normalized vs Denormalized:</em> Some years contain data in &ldquo;database normalized&rdquo;
format with separate stations and rides tables, linked by a common station_id key.
Other years only contain a single de-normalized/merged rides table, with station info included.</p>
<p>But the divvy data contained two way worse problems:</p>
<p><strong>Unstable station id&rsquo;s</strong></p>
<p>In some batches, the station ID is an integer, while in others it is a UUID,
representing schema drift. This drift broke the one-to-one property of station IDs:
60% of station IDs were one-to-many: they were associated with up to 4 unique stations.</p>
<p><img src="/img/id-to-name.jpeg" alt="Non-unique IDs"></p>
<p>For those not familiar with Chicago streets, these intersections are quite far apart:</p>


<div id="/json/bike-id-name.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/bike-id-name.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/bike-id-name.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<p>The standard approach to resolving this issue is to create a column labeling each observation with
the batch it came from (eg. &ldquo;2024-Q1&rdquo;) and use (ID, batch) pairs as the new primary key.
Although this fixes the one-to-many issue, it breaks the injective property of station IDs,
making them many-to-one!</p>
<p><img src="/img/id-batch-to-name.jpeg" alt="Non-unique IDs"></p>
<p><strong>Unstable station name</strong></p>
<p>Looking at the data this way, perhaps the station name is a sufficient primary key?</p>
<p>Unfortunately, station names were also not always one-to-one. For example, the following
locations are all purportedly at Buckingham Fountain:</p>


<div id="/json/buckingham.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/buckingham.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/buckingham.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<p>Similarly, station names were also not always injective.</p>
<p><strong>Imprecise station locations</strong></p>
<p>Recent Divvy historical data batches are published as single denormalized CSV&rsquo;s
containing trip_start_location and trip_end_location geometries.
Maybe the points can be our primary keys?</p>
<p>At first glance, there are some ~900,000 unique points. At MOST I should expect a few thousand!</p>
<p>Maybe this is a floating point precision issue and the points are actually
well-clustered around their true station locations. Maybe I can derive a much
smaller set of representative locations and snap each point to the closest one.</p>
<p><em>Attribute Group-By</em>: I group by attribute (e.g. name, id, batch), compute the
centroid of each group, and measure the maximum point-to-centroid distance per group.
This quantifies the spread or imprecision in using names, ids, batches as primary keys
to actually identify station locations.</p>
<p>In code this would look something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TOLERANCE <span style="color:#f92672">=</span> <span style="color:#ae81ff">1320</span>  <span style="color:#75715e"># feet</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dispersion</span>(x: gpd<span style="color:#f92672">.</span>GeoSeries, metric: Callable <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>std):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Taking centroid of unique points makes us more sensitive to outlier mis-labeled data when</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># using standard deviation as metric. When using max it makes no difference.</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>drop_duplicates()
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> MultiPoint(x<span style="color:#f92672">.</span>values)<span style="color:#f92672">.</span>centroid
</span></span><span style="display:flex;"><span>    radius <span style="color:#f92672">=</span> metric(x<span style="color:#f92672">.</span>distance(c))
</span></span><span style="display:flex;"><span>    diam <span style="color:#f92672">=</span> radius <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>  <span style="color:#75715e"># very rough</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> diam
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>max_spread <span style="color:#f92672">=</span> bike_rides<span style="color:#f92672">.</span>to_crs(LOCAL_CRS)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;name&#39;</span>)[<span style="color:#e6db74">&#39;geometry&#39;</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span>transform(<span style="color:#66d9ef">lambda</span> x: dispersion(x, np<span style="color:#f92672">.</span>max))
</span></span><span style="display:flex;"><span>clusterable <span style="color:#f92672">=</span> max_spread <span style="color:#f92672">&lt;</span> TOLERANCE
</span></span></code></pre></div><p>Based on this method, ~106,000 points can be reduced down to ~1,00 representative
points, but the remaining ~786,000 points are too dispersed to confidently say
the refer to the same point.</p>
<!-- raw HTML omitted -->


<div id="/json/bike-clusters.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/bike-clusters.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/bike-clusters.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<p><em>Spatial Clustering</em>:
As seen above, these ID columns are not necessarly bijective, meaning they are
over-specified. Maybe I should group the points purely by their location, and
ignore their IDs.</p>
<p>There are many ways to cluster points. I&rsquo;ll use an intuitive way as follows:</p>
<ol>
<li>Draw a buffer around each point (66ft is the typical Chicago <a href="https://www.chicago.gov/dam/city/depts/cdot/StreetandSitePlanDesignStandards407.pdf">street width</a>)</li>
<li>Find all buffers that intersect (via unary union)
<ol>
<li>Each unioned buffer shape represents a candidate cluster</li>
<li>Build spatial index on these clusters</li>
</ol>
</li>
<li>For each point, determine which cluster it belongs to (via spatial index query)</li>
<li>Break apart clusters that are:
<ol>
<li>Too dispersed</li>
<li>Have heterogenous attributes (e.g. station names)</li>
</ol>
</li>
</ol>
<p>This method affirms the outcome of the attribute clustering performed above. The
20% of data that is tightly spatially grouped do indeed represent unique stations.
The other 80% of the data can be unioned into clusters that contain up to 7818
points.</p>
<p>The buffer union method suffers from a transitivity issue:</p>
<p>$$
\text{dist}(A,B) &lt; d, \text{dist}(B,C) &lt; d \not \Rightarrow \text{dist}(A,C) &lt; d
$$</p>
<p>We can see that step 5 helps mitigate this issue.</p>


<div id="/json/spatial-bike-clusters.json" class="leaflet" style="height:500px;"></div>
<script>
    function get_bounds(fig) {
        if ('lat' in fig['data'][0]) {
            
            var minLat = Math.min(...fig.data.flatMap(d => 
            d.lat.filter(val => val != null && !isNaN(val))
            ));
            var maxLat = Math.max(...fig.data.flatMap(d => 
                d.lat.filter(val => val != null && !isNaN(val))
            ));
            var minLon = Math.min(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
            var maxLon = Math.max(...fig.data.flatMap(d => 
                d.lon.filter(val => val != null && !isNaN(val))
            ));
        } else if ('geojson' in fig['data'][0]) {
            
            const lons = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => x))
                .filter(x => x != null && !isNaN(x));
            const lats = fig['data']
                .flatMap(d => d['geojson']['features'])
                .flatMap(f => f['geometry']['coordinates'])
                .flatMap(cc => cc.map(([x, y]) => y))
                .filter(y => y != null && !isNaN(y));
            var minLat = Math.min(...lats);
            var maxLat = Math.max(...lats);
            var minLon = Math.min(...lons);
            var maxLon = Math.max(...lons);
        }
        return [minLat, maxLat, minLon, maxLon]
    }

    fetch("/json/spatial-bike-clusters.json")
    .then(response => response.json())
    .then(fig => {
        
        const [minLat, maxLat, minLon, maxLon] = get_bounds(fig)
        const centerLat = (minLat + maxLat) / 2
        const centerLon = (minLon + maxLon) / 2
        const map = L.map("\/json\/spatial-bike-clusters.json").setView([centerLat, centerLon], 10);
        
        
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);
        
        
        
        
        
        
        if (fig.data[0]['type'] === "choropleth") {
            var layerControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);
            var layers = {};  
        }
        
        
        fig.data.forEach((trace, traceIndex) => {
            if (trace.type === 'scattergeo' || trace.type === 'scatter') {
                
                const latitudes = trace.lat;
                const longitudes = trace.lon;
                const color = trace.line?.color || 'blue';
                const weight = trace.line?.width || 2;
                
                let points = [];
                
                for (let i = 0; i < latitudes.length; i++) {
                    const lat = latitudes[i];
                    const lon = longitudes[i];
                    
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        
                        points.push([lat, lon]);
                    } else if (points.length) {
                        
                        L.polyline(points, { color, weight }).addTo(map);
                        points = []; 
                    }
                }
                
                
                if (points.length) {
                    L.polyline(points, { color, weight }).addTo(map);
                }
            }
            else if (trace.type === 'scattermap') {
                
                const color = trace.marker?.color || 'blue';
                const points = trace.lat
                                .map((lat,i) => [trace.lon[i], lat])
                                .filter(([lon,lat]) => lon != null && !isNaN(lon));
                for (const [lon,lat] of points) {
                    L.circle([lat,lon], {'color': color, 'radius': 20}).addTo(map);
                }
                
            }
            else if (trace.type === 'choropleth') {
                const facetName = trace.name || `Layer ${traceIndex + 1}`;

                const layer = L.geoJSON(trace.geojson, {
                    style: feature => ({
                        fillColor: feature.properties.cmap,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.7
                    })}).addTo(map);
                
                
                layerControl.addOverlay(layer, facetName);
                layers[facetName] = layer;

                
                if (traceIndex === 0) {
                    layer.addTo(map);
                }
            }
        });

        
        map.on('overlayadd', e => {
            Object.entries(layers).forEach(([name, layer]) => {
                if (name !== e.name) {
                    map.removeLayer(layer);
                    layerControl.removeLayer(layer);
                    layerControl.addOverlay(layer, name);
                }
            })
        });
    });
</script>
<p>I have to conclude that these points actually represent user locations when
they start/stop trips on their smartphone apps. The drift represents a combination
of GPS uncertainty among tall downtown buildings, and physical user displacement
from the actual station when they interact with the app.</p>
<p><strong>Resolution with GBFS</strong></p>
<p>As a last resort, I looked at and decided to merge the live GBFS feed. This
dataset is intended for app developers, and shows real-time station availability
and such. The problem is it&rsquo;s live and doesn&rsquo;t span the entire historical data range.
Given the schema drift issues presented above, I had no confidence the data was
merge-able with anything but 2024 data. But since I only strictly need 2024 data for
the models I plan to run, this limitation is acceptable.</p>
<p><em>Problem solved!</em></p>
<h3 id="socrata-to-data-frames">Socrata to Data Frames</h3>
<p>As far as I could tell, the Socrata SoQL API returned all data as lists of lists of strings. Since I was making a lot of Socrata calls, I extended the Socrata client like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> sodapy <span style="color:#f92672">import</span> Socrata
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChiClient</span>(Socrata):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, timeout: int):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;data.cityofchicago.org&#34;</span>, 
</span></span><span style="display:flex;"><span>            app_token<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>,
</span></span><span style="display:flex;"><span>            timeout<span style="color:#f92672">=</span>timeout)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get</span>(self, 
</span></span><span style="display:flex;"><span>            resource_id: str, 
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">**</span>params) <span style="color:#f92672">-&gt;</span> pd<span style="color:#f92672">.</span>DataFrame:
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;Collects Socrata response into data frame.&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> super()<span style="color:#f92672">.</span>get(resource_id, <span style="color:#f92672">**</span>params)
</span></span><span style="display:flex;"><span>        df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame<span style="color:#f92672">.</span>from_records(data)
</span></span><span style="display:flex;"><span>        df <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>fix_coltypes(df, resource_id)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> df
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fix_coltypes</span>(self, df: pd<span style="color:#f92672">.</span>DataFrame, resource_id: str):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;Coerce string data into other dtypes&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        coltypes <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_coltypes(resource_id)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> df<span style="color:#f92672">.</span>columns:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> col <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> coltypes<span style="color:#f92672">.</span>keys():
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Column was transformed e.g. SELECT COUNT(col)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># or renamed e.g. SELECT col AS alias</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> coltypes[col] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;calendar_date&#39;</span>:
</span></span><span style="display:flex;"><span>                df[col] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>to_datetime(df[col])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> coltypes[col] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;number&#39;</span>:
</span></span><span style="display:flex;"><span>                df[col] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>to_numeric(df[col])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> df
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_coltypes</span>(self, resource_id: str):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;Query basic table metadata&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        meta <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_metadata(resource_id)
</span></span><span style="display:flex;"><span>        colnames <span style="color:#f92672">=</span> [c[<span style="color:#e6db74">&#39;fieldName&#39;</span>] <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> meta[<span style="color:#e6db74">&#39;columns&#39;</span>]]
</span></span><span style="display:flex;"><span>        coltypes <span style="color:#f92672">=</span> [c[<span style="color:#e6db74">&#39;dataTypeName&#39;</span>] <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> meta[<span style="color:#e6db74">&#39;columns&#39;</span>]]
</span></span><span style="display:flex;"><span>        coltypes <span style="color:#f92672">=</span> {c: ct <span style="color:#66d9ef">for</span> c,ct <span style="color:#f92672">in</span> zip(colnames, coltypes)}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> coltypes
</span></span></code></pre></div><p>Usage comparison:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>In <span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: TOTAL_RIDERSHIP_TABLE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;6iiy-9s97&#34;</span>
</span></span><span style="display:flex;"><span>In <span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>: soc_client <span style="color:#f92672">=</span> Socrata<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.cityofchicago.org&#34;</span>, app_token<span style="color:#f92672">=</span>None, timeout<span style="color:#f92672">=</span>60<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>In <span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>: chi_client <span style="color:#f92672">=</span> ChiClient<span style="color:#f92672">(</span>60<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>In <span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>: original_data <span style="color:#f92672">=</span> soc_client.get<span style="color:#f92672">(</span>TOTAL_RIDERSHIP_TABLE, limit<span style="color:#f92672">=</span>5<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>In <span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>: pretty_data <span style="color:#f92672">=</span> chi_client.get<span style="color:#f92672">(</span>TOTAL_RIDERSHIP_TABLE, limit<span style="color:#f92672">=</span>5<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>In <span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>: print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Original response:&#34;</span>, original_data, sep<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Original response:
</span></span><span style="display:flex;"><span><span style="color:#f92672">[{</span><span style="color:#e6db74">&#39;service_date&#39;</span>: <span style="color:#e6db74">&#39;2001-01-01T00:00:00.000&#39;</span>, <span style="color:#e6db74">&#39;day_type&#39;</span>: <span style="color:#e6db74">&#39;U&#39;</span>, <span style="color:#e6db74">&#39;bus&#39;</span>: <span style="color:#e6db74">&#39;297192&#39;</span>, <span style="color:#e6db74">&#39;rail_boardings&#39;</span>: <span style="color:#e6db74">&#39;126455&#39;</span>, <span style="color:#e6db74">&#39;total_rides&#39;</span>: <span style="color:#e6db74">&#39;423647&#39;</span><span style="color:#f92672">}</span>, <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;service_date&#39;</span>: <span style="color:#e6db74">&#39;2001-01-02T00:00:00.000&#39;</span>, <span style="color:#e6db74">&#39;day_type&#39;</span>: <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;bus&#39;</span>: <span style="color:#e6db74">&#39;780827&#39;</span>, <span style="color:#e6db74">&#39;rail_boardings&#39;</span>: <span style="color:#e6db74">&#39;501952&#39;</span>, <span style="color:#e6db74">&#39;total_rides&#39;</span>: <span style="color:#e6db74">&#39;1282779&#39;</span><span style="color:#f92672">}</span>, <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;service_date&#39;</span>: <span style="color:#e6db74">&#39;2001-01-03T00:00:00.000&#39;</span>, <span style="color:#e6db74">&#39;day_type&#39;</span>: <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;bus&#39;</span>: <span style="color:#e6db74">&#39;824923&#39;</span>, <span style="color:#e6db74">&#39;rail_boardings&#39;</span>: <span style="color:#e6db74">&#39;536432&#39;</span>, <span style="color:#e6db74">&#39;total_rides&#39;</span>: <span style="color:#e6db74">&#39;1361355&#39;</span><span style="color:#f92672">}</span>, <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;service_date&#39;</span>: <span style="color:#e6db74">&#39;2001-01-04T00:00:00.000&#39;</span>, <span style="color:#e6db74">&#39;day_type&#39;</span>: <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;bus&#39;</span>: <span style="color:#e6db74">&#39;870021&#39;</span>, <span style="color:#e6db74">&#39;rail_boardings&#39;</span>: <span style="color:#e6db74">&#39;550011&#39;</span>, <span style="color:#e6db74">&#39;total_rides&#39;</span>: <span style="color:#e6db74">&#39;1420032&#39;</span><span style="color:#f92672">}</span>, <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;service_date&#39;</span>: <span style="color:#e6db74">&#39;2001-01-05T00:00:00.000&#39;</span>, <span style="color:#e6db74">&#39;day_type&#39;</span>: <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;bus&#39;</span>: <span style="color:#e6db74">&#39;890426&#39;</span>, <span style="color:#e6db74">&#39;rail_boardings&#39;</span>: <span style="color:#e6db74">&#39;557917&#39;</span>, <span style="color:#e6db74">&#39;total_rides&#39;</span>: <span style="color:#e6db74">&#39;1448343&#39;</span><span style="color:#f92672">}]</span>
</span></span><span style="display:flex;"><span>In <span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>: print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;DataFrame response:&#34;</span>, pretty_data, sep<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>DataFrame response:
</span></span><span style="display:flex;"><span>  service_date day_type     bus  rail_boardings  total_rides
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>   2001-01-01        U  <span style="color:#ae81ff">297192</span>          <span style="color:#ae81ff">126455</span>       <span style="color:#ae81ff">423647</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>   2001-01-02        W  <span style="color:#ae81ff">780827</span>          <span style="color:#ae81ff">501952</span>      <span style="color:#ae81ff">1282779</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>   2001-01-03        W  <span style="color:#ae81ff">824923</span>          <span style="color:#ae81ff">536432</span>      <span style="color:#ae81ff">1361355</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>   2001-01-04        W  <span style="color:#ae81ff">870021</span>          <span style="color:#ae81ff">550011</span>      <span style="color:#ae81ff">1420032</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>   2001-01-05        W  <span style="color:#ae81ff">890426</span>          <span style="color:#ae81ff">557917</span>      <span style="color:#ae81ff">1448343</span>
</span></span></code></pre></div>
    <ul class="tags">
    
      <li><a class="tag" href="/tags/data-science">data science</a></li>
    
      <li><a class="tag" href="/tags/open-data">open data</a></li>
    
      <li><a class="tag" href="/tags/socrata">Socrata</a></li>
    
      <li><a class="tag" href="/tags/amazon-s3">Amazon S3</a></li>
    
      <li><a class="tag" href="/tags/geopandas">geopandas</a></li>
    
      <li><a class="tag" href="/tags/panel-data">panel data</a></li>
    
</ul>

  </div>
</section>

    <section><span style="color: #999999;">Nifty <a href="https://codepen.io/wbeeftink/pen/dIaDH">tech tag lists</a> from <a class="pen-owner-link" href="https://codepen.io/wbeeftink">Wouter Beeftink</a> </span>
      
    </section>
  </div>
  
  <script src="https://code.jquery.com/jquery-3.6.4.slim.min.js" integrity="sha256-a2yjHM4jnF9f54xUQakjZGaqYs/V1CYvWpoqZzC2/Bw=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
  
  <script src="https://unpkg.com/smoothscroll-polyfill@0.4.4/dist/smoothscroll.min.js" integrity="sha384-EYn4rWu1DHvYD0sSSSbMEtXQmMl58CFJd897806+RT1jJVYbhuZlZMN6yG9nCyFa" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/smoothscroll-anchor-polyfill@1.3.2/dist/index.min.js" integrity="sha384-EY9NBEHCFbZANmPcTm7CgG8OhsFILy0VBLG85pF6OIpP42NVbZVNsFOc23PYTCkB" crossorigin="anonymous"></script>
  
  <script async src="/js/resume.js"></script>
  

  

  
</body>
</html>
